---
title: " synergy"
output: html_notebook
---
###TODO 
* why the same function fails at ZIP. It doesn't? i dont get it
* melting(?) output into long. Call python module into R. Eaasy
* add cell_line info

load libs
```{r}
library(synergyfinder)
library(naniar) # probably not needed
library(purrr) # probably not needed
library(nleqslv) # for debug the drm
```
basic read input using Alina's sorted data with celllines added (to help differentiate between batch1 and batch3)

```{r}
read.csv('/Users/zagidull/Desktop/processed_sorted_with_cellline.csv',sep = ";",
         colClasses = c('numeric', 'numeric','character', 'character','numeric','character','numeric','numeric',
                        'character','character','numeric','numeric')) -> input.sample

reshaped <- ReshapeData(input.sample,data.type = 'inhibition')
```
I know that 104 combo throws error when calculating Loewe synergy score, because i do 
```{r}
debugonce(Loewe)
options(error = recover)
dump.frames(dumpto = "last.dump", to.file = FALSE,include.GlobalEnv = FALSE)
debugger(dump = last.dump)
```
here i compose a new variable that consist of dose.response.mat and drug.pairs that throw in the error
```{r}
reshaped$dose.response.mats[104] -> oshibka
reshaped$drug.pairs[104,] -> imena
erl <- list()
erl$dose.response.mats <- oshibka
erl$drug.pairs <- imena
```
let's create a test case that we know works. It is for drug combo 103
```{r}
reshaped$dose.response.mats[103] -> neoshibka
reshaped$drug.pairs[103,] -> neimena
neerl <- list()
neerl$dose.response.mats <- neoshibka
neerl$drug.pairs <- neimena
```
let's create a case when both combos work
```{r}
reshaped$dose.response.mats[102] -> eneoshibka
reshaped$drug.pairs[102,] -> eneimena
eneerl <- list()
eneerl$dose.response.mats <- eneoshibka
eneerl$drug.pairs <- eneimena
enew <- list()
enew <- eneerl
enew$drug.pairs[2,] <- neerl$drug.pairs[1,]
enew$dose.response.mats[2] <- neerl$dose.response.mats[1]
```
let's create a case when out of two combos only one works
```{r}
new <- list()
new <- neerl
new$drug.pairs[2,] <- erl$drug.pairs[1,]
new$dose.response.mats[2] <- erl$dose.response.mats[1]
```

to test it throws the error I do
```{r}
today.Loewe <- CalculateSynergy(data = erl,method = "Loewe",correction = TRUE, Emin = 0, Emax = 100)
```
this throws error 
Error in nleqslv(max(drug.col.par[2] + 1, drug.row.par[2] + 1), eq, method = "Newton") : 
  initial value of fn function contains non-finite values (starting at index=1)
  Check initial x and/or correctness of function
Let's try to wrap it in tryCatch() to make it return NA
```{r}
irr2 <- function (x) {
  out <- tryCatch(CalculateSynergy(data = x,method = "Loewe",correction = TRUE, Emin = 0, Emax = 100), error = function(e) NA)
  return(out)
}
```
this works creating a dummy empty NA matrix for when there is one pair of drugs
```{r}
irr3 <- function (x) {
# scores <- list()
  method <- "Loewe"
 
  out <- tryCatch(CalculateSynergy(data = x,method = "Loewe",correction = TRUE, Emin = 0, Emax = 100), error = function(e) {
  x$method <- method
  x$scores <- x$dose.response.mats
#  x$scores[!is.na(x$scores)] <- NA
#  x$scores <- replace(x$scores, !is.na(x$scores), NA)
#  purrr::map(!is.na(x$scores), NA)
  x$scores <- lapply(x$scores, function(z) ifelse(!is.na(z), NA, z))
  return(x)
  })
  return(out)
}
```
here is the original of Loewe function
```{r}
Loewe_modded <- function (response.mat, correction = TRUE, Emin = NA, Emax = NA, 
    nan.handle = c("LL4", "L4")) 
{
    if (correction) {
        response.mat <- BaselineCorrectionSD(response.mat, Emin = Emin, 
            Emax = Emax, nan.handle)$corrected.mat
    }
    single.fit <- FittingSingleDrug(response.mat)
    drug.col.model <- single.fit$drug.col.model
    drug.col.par <- coef(drug.col.model)
    d1.fun <- function(conc, drug.col.par) {
        (drug.col.par[3] + drug.col.par[2] * (conc/drug.col.par[4])^drug.col.par[1])/(1 + 
            (conc/drug.col.par[4])^drug.col.par[1])
    }
    drug.row.model <- single.fit$drug.row.model
    drug.row.par <- coef(drug.row.model)
    d2.fun <- function(conc, drug.row.par) {
        (drug.row.par[3] + drug.row.par[2] * (conc/drug.row.par[4])^drug.row.par[1])/(1 + 
            (conc/drug.row.par[4])^drug.row.par[1])
    }
    row.conc <- as.numeric(rownames(response.mat))[-1]
    col.conc <- as.numeric(colnames(response.mat))[-1]
    loewe.mat <- response.mat
    for (i in 1:length(col.conc)) {
        for (j in 1:length(row.conc)) {
            x1 <- col.conc[i]
            x2 <- row.conc[j]
            eq <- function(x) {
                x1/(drug.col.par[4] * (((x - drug.col.par[3])/(drug.col.par[2] - 
                  x))^(1/drug.col.par[1]))) + x2/(drug.row.par[4] * 
                  (((x - drug.row.par[3])/(drug.row.par[2] - 
                    x))^(1/drug.row.par[1]))) - 1
            }
            slv <- nleqslv(max(drug.col.par[2] + 1, drug.row.par[2] + 
                1), eq, method = "Newton")
            if (slv$termcd == 1) {
                loewe.mat[j + 1, i + 1] <- slv$x
            }
            else {
                y.loewe1 <- d1.fun(x1 + x2, drug.col.par)
                y.loewe2 <- d2.fun(x1 + x2, drug.row.par)
                loewe.mat[j + 1, i + 1] <- ifelse(y.loewe1 > 
                  y.loewe2, y.loewe1, y.loewe2)
            }
        }
    }
    return(response.mat - loewe.mat)
}
```
here is Loewe is modded version.
```{r}
Loewe <- function (response.mat,correction, Emin = NA, Emax = NA,nan.handle = c("LL4", "L4")) {
# scores <- list()
#  method <- "Loewe"
  out <- tryCatch(Loewe_modded(response.mat,correction = correction, Emin = Emin, Emax = Emax, 
    nan.handle = nan.handle), error = function(e) NA)
#  {
#  x$method <- method
#  x$scores <- x$dose.response.mats
#  x$scores[!is.na(x$scores)] <- NA
#  x$scores <- replace(x$scores, !is.na(x$scores), NA)
#  purrr::map(!is.na(x$scores), NA)
#  x$scores <- lapply(x$scores, function(z) ifelse(!is.na(z), NA, z))
#  return(x)
#  })
  return(out)
}
```
here is calculate synergy with added tryCatch to Loewe method
```{r}
CalculateSynergy <- function (data, method = "ZIP", correction = TRUE, Emin = 0, 
    Emax = 100, nan.handle = c("LL4", "L4")) 
{
    if (!is.list(data)) {
        stop("Input data is not a list format!")
    }
    if (!method %in% c("ZIP", "HSA", "Bliss", "Loewe")) {
        stop("The method parameter can only be one of the following: ZIP, HSA, Bliss and Loewe.")
    }
    dose.response.mats <- data$dose.response.mats
    num.pairs <- length(dose.response.mats)
    scores <- list()
    nan.handle <- match.arg(nan.handle)
    for (i in 1:num.pairs) {
        response.mat <- dose.response.mats[[i]]
        scores[[i]] <- switch(method, 
            ZIP = ZIP(response.mat = response.mat, correction = correction, Emin = Emin, Emax = Emax), 
            HSA = HSA(response.mat, correction, Emin = Emin, Emax = Emax, nan.handle), 
            Bliss = Bliss(response.mat, correction, Emin = Emin, Emax = Emax, nan.handle), 
            Loewe = Loewe(response.mat, correction, Emin = Emin, Emax = Emax, nan.handle))
    }
    data$scores <- scores
    data$method <- method
    return(data)
}

```
modded ZIP. 
```{r}
ZIP_modded <- function (response.mat, correction = TRUE, Emin = 0, Emax = 100, 
    nan.handle = c("LL4", "L4")) 
{
    if (correction) {
        nan.handle <- match.arg(nan.handle)
        response.mat <- BaselineCorrectionSD(response.mat, NA, 
            NA, nan.handle)$corrected.mat
    }
    single.fitted <- FittingSingleDrug(response.mat, fixed = c(NA, 
        Emin, Emax, NA), nan.handle)
    drug.col.response <- single.fitted$drug.col.fitted
    drug.row.response <- single.fitted$drug.row.fitted
    updated.single.mat <- mat.or.vec(nrow(response.mat), ncol(response.mat))
    colnames(updated.single.mat) <- colnames(response.mat)
    rownames(updated.single.mat) <- rownames(response.mat)
    updated.single.mat[1, c(2:ncol(response.mat))] <- drug.col.response
    updated.single.mat[c(2:nrow(response.mat)), 1] <- drug.row.response
    updated.col.mat <- updated.single.mat
    for (i in 2:ncol(response.mat)) {
        tmp <- as.data.frame(mat.or.vec(nrow(response.mat) - 
            1, 0))
        tmp$dose <- as.numeric(rownames(response.mat)[-1])
        tmp$inhibition <- response.mat[c(2:nrow(response.mat)), 
            i]
        tmp.min <- updated.single.mat[1, i]
        if (var(tmp$inhibition, na.rm = TRUE) == 0) {
            tmp$inhibition[1] <- tmp$inhibition[1] - 10^-10
        }
        tmp.model <- drm(inhibition ~ dose, data = tmp, fct = L.4(fixed = c(NA, 
            tmp.min, Emax, NA)), na.action = na.omit)
        tmp$fitted.inhibition <- suppressWarnings(fitted(tmp.model))
        if (tmp$fitted.inhibition[nrow(response.mat) - 1] < 0) 
            tmp$fitted.inhibition[nrow(response.mat) - 1] <- tmp.min
        updated.col.mat[c(2:nrow(response.mat)), i] <- tmp$fitted.inhibition
    }
    updated.row.mat <- updated.single.mat
    for (i in 2:nrow(response.mat)) {
        tmp <- as.data.frame(mat.or.vec(ncol(response.mat) - 
            1, 0))
        tmp$dose <- as.numeric(colnames(response.mat)[-1])
        tmp$inhibition <- response.mat[i, c(2:ncol(response.mat))]
        tmp.min <- updated.single.mat[i, 1]
        if (var(tmp$inhibition, na.rm = TRUE) == 0) {
            tmp$inhibition[1] <- tmp$inhibition[1] - 10^-10
        }
        tmp.model <- drm(inhibition ~ dose, data = tmp, fct = L.4(fixed = c(NA, 
            tmp.min, Emax, NA)), na.action = na.omit)
        tmp$fitted.inhibition <- suppressWarnings(fitted(tmp.model))
        if (tmp$fitted.inhibition[ncol(response.mat) - 1] < 0) 
            tmp$fitted.inhibition[ncol(response.mat) - 1] <- tmp.min
        updated.row.mat[i, c(2:ncol(response.mat))] <- tmp$fitted.inhibition
    }
    fitted.mat <- (updated.col.mat + updated.row.mat)/2
    zip.mat <- updated.single.mat
    for (i in 2:nrow(updated.single.mat)) {
        for (j in 2:ncol((updated.single.mat))) {
            zip.mat[i, j] <- updated.single.mat[i, 1] + updated.single.mat[1, 
                j] - updated.single.mat[i, 1] * updated.single.mat[1, 
                j]/100
        }
    }
    fitted.mat[1, 1] <- 0
    zip.mat[1, 1] <- 0
    fitted.mat <- apply(fitted.mat, c(1, 2), function(x) ifelse(x > 
        100, 100, x))
    delta.mat <- (fitted.mat - zip.mat)
    delta.mat
}

```
here is mod of ZIP with trycatch. Fails by priting out NA for every single drug comb. 
```{r}
ZIP <- function (response.mat,correction, Emin = NA, Emax = NA,nan.handle = c("LL4", "L4")) {
# scores <- list()
#  method <- "Loewe"
  out <- tryCatch(ZIP_modded(response.mat,correction = correction, Emin = Emin, Emax = Emax, 
    nan.handle = nan.handle), error = function(e) NA)
#  {
#  x$method <- method
#  x$scores <- x$dose.response.mats
#  x$scores[!is.na(x$scores)] <- NA
#  x$scores <- replace(x$scores, !is.na(x$scores), NA)
#  purrr::map(!is.na(x$scores), NA)
#  x$scores <- lapply(x$scores, function(z) ifelse(!is.na(z), NA, z))
#  return(x)
#  })
  return(out)
}
```
BLISS
```{r}
Bliss <- function (response.mat = response.mat,correction = correction, Emin = NA, Emax = NA,nan.handle = c("LL4", "L4")) {
# scores <- list()
#  method <- "ZIP"
  out <- tryCatch(BLISS_modded(response.mat,correction = correction, Emin = Emin, Emax = Emax, 
    nan.handle = nan.handle), error = function(e) NA)
#  {
#  x$method <- method
#  x$scores <- x$dose.response.mats
#  x$scores[!is.na(x$scores)] <- NA
#  x$scores <- replace(x$scores, !is.na(x$scores), NA)
#  purrr::map(!is.na(x$scores), NA)
#  x$scores <- lapply(x$scores, function(z) ifelse(!is.na(z), NA, z))
#  return(x)
#  })
  return(out)
}
```
BLISS_modded 
```{r}
BLISS_modded<- function (response.mat, correction = TRUE, Emin = NA, Emax = NA, 
    nan.handle = c("LL4", "L4")) 
{
    if (correction) {
        response.mat <- BaselineCorrectionSD(response.mat, Emin = Emin, 
            Emax = Emax, nan.handle)$corrected.mat
    }
    drug1.response <- response.mat[, 1]
    drug2.response <- response.mat[1, ]
    ref.mat <- response.mat
    for (i in 2:nrow(response.mat)) {
        for (j in 2:ncol(response.mat)) {
            ref.mat[i, j] <- drug1.response[i] + drug2.response[j] - 
                drug1.response[i] * drug2.response[j]/100
        }
    }
    syn.mat <- response.mat - ref.mat
    syn.mat
}

```
HSA
```{r}
HSA <- function (response.mat = response.mat,correction = correction, Emin = NA, Emax = NA,nan.handle = c("LL4", "L4")) {
# scores <- list()
#  method <- "ZIP"
  out <- tryCatch(HSA_modded(response.mat,correction = correction, Emin = Emin, Emax = Emax, 
    nan.handle = nan.handle), error = function(e) NA)
#  {
#  x$method <- method
#  x$scores <- x$dose.response.mats
#  x$scores[!is.na(x$scores)] <- NA
#  x$scores <- replace(x$scores, !is.na(x$scores), NA)
#  purrr::map(!is.na(x$scores), NA)
#  x$scores <- lapply(x$scores, function(z) ifelse(!is.na(z), NA, z))
#  return(x)
#  })
  return(out)
}
```
HSA_modded
```{r}
HSA_modded <-function (response.mat, correction = TRUE, Emin = NA, Emax = NA, 
    nan.handle = c("LL4", "L4")) 
{
    if (correction) {
        response.mat <- BaselineCorrectionSD(response.mat, Emin = Emin, 
            Emax = Emax, nan.handle)$corrected.mat
    }
    drug1.response <- response.mat[, 1]
    drug2.response <- response.mat[1, ]
    ref.mat <- response.mat
    for (i in 2:nrow(response.mat)) {
        for (j in 2:ncol(response.mat)) {
            ref.mat[i, j] <- ifelse(drug1.response[i] > drug2.response[j], 
                drug1.response[i], drug2.response[j])
        }
    }
    syn.mat <- response.mat - ref.mat
    syn.mat
}

```

files were saved using 
`sink()`, `print(with max option set)`, `sink()`
and using simple `save()` to rds

original calculate synergy and zip functions
```{r}
CalculateSynergy <- function (data, method = "ZIP", correction = TRUE, Emin = 0, 
    Emax = 100, nan.handle = c("LL4", "L4")) 
{
    if (!is.list(data)) {
        stop("Input data is not a list format!")
    }
    if (!method %in% c("ZIP", "HSA", "Bliss", "Loewe")) {
        stop("The method parameter can only be one of the following: ZIP, HSA, Bliss and Loewe.")
    }
    dose.response.mats <- data$dose.response.mats
    num.pairs <- length(dose.response.mats)
    scores <- list()
    nan.handle <- match.arg(nan.handle)
    for (i in 1:num.pairs) {
        response.mat <- dose.response.mats[[i]]
        scores[[i]] <- switch(method, ZIP = ZIP(response.mat, 
            correction, Emin = Emin, Emax = Emax, nan.handle), 
            HSA = HSA(response.mat, correction, Emin = Emin, 
                Emax = Emax, nan.handle), Bliss = Bliss(response.mat, 
                correction, Emin = Emin, Emax = Emax, nan.handle), 
            Loewe = Loewe(response.mat, correction, Emin = Emin, 
                Emax = Emax, nan.handle))
    }
    data$scores <- scores
    data$method <- method
    return(data)
}
ZIP <- function (response.mat, correction = TRUE, Emin = 0, Emax = 100, 
    nan.handle = c("LL4", "L4")) 
{
    if (correction) {
        nan.handle <- match.arg(nan.handle)
        response.mat <- BaselineCorrectionSD(response.mat, NA, 
            NA, nan.handle)$corrected.mat
    }
    single.fitted <- FittingSingleDrug(response.mat, fixed = c(NA, 
        Emin, Emax, NA), nan.handle)
    drug.col.response <- single.fitted$drug.col.fitted
    drug.row.response <- single.fitted$drug.row.fitted
    updated.single.mat <- mat.or.vec(nrow(response.mat), ncol(response.mat))
    colnames(updated.single.mat) <- colnames(response.mat)
    rownames(updated.single.mat) <- rownames(response.mat)
    updated.single.mat[1, c(2:ncol(response.mat))] <- drug.col.response
    updated.single.mat[c(2:nrow(response.mat)), 1] <- drug.row.response
    updated.col.mat <- updated.single.mat
    for (i in 2:ncol(response.mat)) {
        tmp <- as.data.frame(mat.or.vec(nrow(response.mat) - 
            1, 0))
        tmp$dose <- as.numeric(rownames(response.mat)[-1])
        tmp$inhibition <- response.mat[c(2:nrow(response.mat)), 
            i]
        tmp.min <- updated.single.mat[1, i]
        if (var(tmp$inhibition, na.rm = TRUE) == 0) {
            tmp$inhibition[1] <- tmp$inhibition[1] - 10^-10
        }
        tmp.model <- drm(inhibition ~ dose, data = tmp, fct = L.4(fixed = c(NA, 
            tmp.min, Emax, NA)), na.action = na.omit)
        tmp$fitted.inhibition <- suppressWarnings(fitted(tmp.model))
        if (tmp$fitted.inhibition[nrow(response.mat) - 1] < 0) 
            tmp$fitted.inhibition[nrow(response.mat) - 1] <- tmp.min
        updated.col.mat[c(2:nrow(response.mat)), i] <- tmp$fitted.inhibition
    }
    updated.row.mat <- updated.single.mat
    for (i in 2:nrow(response.mat)) {
        tmp <- as.data.frame(mat.or.vec(ncol(response.mat) - 
            1, 0))
        tmp$dose <- as.numeric(colnames(response.mat)[-1])
        tmp$inhibition <- response.mat[i, c(2:ncol(response.mat))]
        tmp.min <- updated.single.mat[i, 1]
        if (var(tmp$inhibition, na.rm = TRUE) == 0) {
            tmp$inhibition[1] <- tmp$inhibition[1] - 10^-10
        }
        tmp.model <- drm(inhibition ~ dose, data = tmp, fct = L.4(fixed = c(NA, 
            tmp.min, Emax, NA)), na.action = na.omit)
        tmp$fitted.inhibition <- suppressWarnings(fitted(tmp.model))
        if (tmp$fitted.inhibition[ncol(response.mat) - 1] < 0) 
            tmp$fitted.inhibition[ncol(response.mat) - 1] <- tmp.min
        updated.row.mat[i, c(2:ncol(response.mat))] <- tmp$fitted.inhibition
    }
    fitted.mat <- (updated.col.mat + updated.row.mat)/2
    zip.mat <- updated.single.mat
    for (i in 2:nrow(updated.single.mat)) {
        for (j in 2:ncol((updated.single.mat))) {
            zip.mat[i, j] <- updated.single.mat[i, 1] + updated.single.mat[1, 
                j] - updated.single.mat[i, 1] * updated.single.mat[1, 
                j]/100
        }
    }
    fitted.mat[1, 1] <- 0
    zip.mat[1, 1] <- 0
    fitted.mat <- apply(fitted.mat, c(1, 2), function(x) ifelse(x > 
        100, 100, x))
    delta.mat <- (fitted.mat - zip.mat)
    delta.mat
}

```
#### what actually worked is to have `today.full.ZIP <- CalculateSynergy(reshaped)`